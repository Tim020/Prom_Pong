import RPi.GPIO as GPIO
import time
import thread
import threading


class Audio:

	# Defines the length of time each note value should last for
    __CROTCHET=0.5
    __QUAVER=0.25
    __SEMIQUAVER=0.125
		
    def __init__(self):
        GPIO.setwarnings(False)
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(4, GPIO.OUT)  # pin 4 for data selector, bit 0
        GPIO.setup(18, GPIO.OUT)  # pin 18 for data selector, bit 1
        GPIO.setup(17, GPIO.OUT)  # pin 17 for PWM audio

    # A function to enable one of three audio channels
    # Line: 0 for off, 1 for osc1, 2 for osc2, 3 for gpio PWM
    # Delay: length of time the channel is enabled in seconds
    def __enable_audio_line(self, line, delay):
        if line == 1:
            GPIO.output(4, True)
            time.sleep(delay)
            GPIO.output(4, False)
        if line == 2:
            GPIO.output(18, True)
            time.sleep(delay)
            GPIO.output(18, False)
        if line == 3:
            GPIO.output(4, True)
            GPIO.output(18, True)
            time.sleep(delay)
            GPIO.output(4, False)
            GPIO.output(18, False)

    # A function to enable sounding the tone generated by osc1 for a given delay
    def tone1(self, delay):
        try:
            thread.start_new_thread(self.__enable_audio_line, (1, delay,))
        except:
            pass

    # A function to enable sounding the tone generated by osc2 for a given delay
    def tone2(self, delay):
        try:
            thread.start_new_thread(self.__enable_audio_line, (2, delay,))
        except:
            pass

    # Outputs a single tone to GPIO pin 17 using PWM
    # period: period of each pulse in the tone
    # mark & space: sets the mark-space ratio - should add up to 1
    # note_val: the length of time that the tone should sound for, in seconds
    def __play_tone(self, period, note_val=__QUAVER, mark=0.5):
        
        if (mark >= 1):
            raise ValueError('Invalid mark-space ratio')
        else:
            space = 1 - mark
            while (note_val > 0):
                GPIO.output(17, True)
                time.sleep(period * mark)
                GPIO.output(17, False)
                time.sleep(period * space)
                note_val -= period
            return
        
            
    
	# Outputs nothing to GPIO pin 17 for a given length of time
	def __play_rest(self, note_val=self.__QUAVER):
			GPIO.output(17, False)
			time.sleep(note_val)

    # Plays the intro music, private as it needs to be threaded, call from play_intro_music() instead
    def play_intro_music(self):
        GPIO.output(4, True)
        GPIO.output(18, True)
        
        for i in range(0,3):
            self.__play_tone(1/392.00) #Play G4 quaver
            self.__play_tone(1/261.63) #Play C4 quaver
            self.__play_tone(1/311.13, self.__SEMIQUAVER) #Play Ef4 semiquaver
            self.__play_tone(1/349.23, self.__SEMIQUAVER) #Play F4 semiquaver
        	
        for i in range(0,2):
            self.__play_tone(1/392.00) #Play G4 quaver
            self.__play_tone(1/261.63) #Play C4 quaver
            self.__play_tone(1/329.63, self.__SEMIQUAVER) #Play E4 semiquaver
            self.__play_tone(1/349.23, self.__SEMIQUAVER) #Play F4 semiquaver
        	
        for i in range(0,3):
            self.__play_tone(1/392.00) #Play G4 quaver
            self.__play_tone(1/261.63) #Play C4 quaver
            self.__play_tone(1/311.13, self.__SEMIQUAVER) #Play Ef4 semiquaver
            self.__play_tone(1/349.23, self.__SEMIQUAVER) #Play F4 semiquaver
        	
        self.__play_tone(1/261.63, self.__CROTCHET) #Play C4 crotchet
		
        GPIO.output(4, False)
        GPIO.output(18, False)
